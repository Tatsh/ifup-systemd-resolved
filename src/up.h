/**
 * @file up.h
 * @brief Functions used by `ifup-systemd-resolved` to set DNS and domain information.
 */
#pragma once
#include <QtNetwork/QNetworkInterface>

#include "constants.h"
#include "ifupdebug.h"
#include "resolve1_interface.h"
#include "specialtypes.h"

/**
 * A container class for the Resolve1Manager interface.
 *
 * Because `Resolve1Manager` is generated by `qdbusxml2cpp`, and `qdbusxml2cpp` does not allow
 * outputting the methods as virtual, this class is used to contain the interface at runtime, and
 * the mock during testing.
 *
 * @tparam Manager The type of the Resolve1Manager interface.
 */
template <class Manager>
class Resolve1ManagerContainer {
public:
    /**
     * Constructor for Resolve1ManagerContainer.
     *
     * @param iface The Resolve1Manager interface to be contained.
     */
    Resolve1ManagerContainer(Manager &iface) : iface_(iface) {
    }
    /**
     * Get the contained interface.
     *
     * @return A reference to the contained `Resolve1Manager` interface.
     */
    Manager &iface() const {
        return iface_;
    }

private:
    Manager &iface_;
};
/**
 * Generate addresses for the call to `org.freedesktop.resolve1` `SetLinkDNS`.
 * Requires environment variables `DNS1` and `DNS2` to be set to valid IP addresses.
 *
 * @return A unique pointer to a LinkDnsIpList containing the addresses.
 */
LinkDnsIpList generateAddresses();
/**
 * Generate domains for the call to `org.freedesktop.resolve1` `SetLinkDomains`.
 * Requires the environment variable `DNS_SUFFIX` to be set to a space-separated list of domain
 * names. Each domain will be added as a LinkDomain object with the second field set to false.
 *
 * @return A unique pointer to a LinkDomainList containing the domains.
 */
LinkDomainList generateDomains();
/**
 * Call `SetLinkDNS` on the `Resolve1Manager` interface passed in.
 *
 * This function retrieves the DNS addresses from environment variables `DNS1` and `DNS2`.
 *
 * This function blocks until the response from D-Bus is received.
 *
 * @tparam Manager The type of the Resolve1Manager interface.
 * @param container The Resolve1Manager-containing object.
 * @param devIndex The index of the network device.
 * @return true if the call was successful, false otherwise.
 *
 * @see generateAddresses()
 */
template <class Manager>
bool doSetLinkDns(Resolve1ManagerContainer<Manager> &container, const int devIndex) {
    auto dnsArgs = generateAddresses();
    if (dnsArgs.length()) {
        auto res = container.iface().SetLinkDNS(devIndex, dnsArgs);
        res.waitForFinished();
        if (res.isError()) {
            qCCritical(LOG_IFUP_SYSTEMD_RESOLVED) << "SetLinkDNS failed.";
            return false;
        }
    }
    return true;
}
/**
 * Call `SetLinkDomains` on the `Resolve1Manager` interface passed in.
 *
 * This function retrieves the domains from the environment variable `DNS_SUFFIX` (space-separated
 * list).
 *
 * This function blocks until the response from D-Bus is received.
 *
 * @tparam Manager The type of the Resolve1Manager interface.
 * @param container The Resolve1Manager-containing object.
 * @param devIndex The index of the network device.
 * @return true if the call was successful, false otherwise.
 *
 * @see generateDomains()
 */
template <class Manager>
bool doSetLinkDomains(Resolve1ManagerContainer<Manager> &container, const int devIndex) {
    auto domainsArg = generateDomains();
    if (domainsArg.length()) {
        auto res = container.iface().SetLinkDomains(devIndex, domainsArg);
        res.waitForFinished();
        if (res.isError()) {
            qCCritical(LOG_IFUP_SYSTEMD_RESOLVED) << "SetLinkDomains failed.";
            return false;
        }
    }
    return true;
}
/**
 * Call `SetLinkDNSSEC` on the `Resolve1Manager` interface passed in.
 *
 * This function retrieves the DNSSEC value from the environment variable `DNSSEC`. If the value is
 * `default`, empty string is passed to D-Bus.
 *
 * This function blocks until the response from D-Bus is received.
 *
 * @tparam Manager The type of the Resolve1Manager interface.
 * @param container The Resolve1Manager-containing object.
 * @param devIndex The index of the network device.
 * @return true if the call was successful, false otherwise.
 */
template <class Manager>
bool doSetLinkDnssec(Resolve1ManagerContainer<Manager> &container, const int devIndex) {
    auto dnsSec =
        QString(qEnvironmentVariable(Strings::EnvironmentVariableNames::dnsSec)).trimmed();
    if (dnsSec.length()) {
        auto res = container.iface().SetLinkDNSSEC(
            devIndex, dnsSec == Strings::dnsSecDefaultValue ? Strings::empty : dnsSec);
        res.waitForFinished();
        if (res.isError()) {
            qCCritical(LOG_IFUP_SYSTEMD_RESOLVED) << "SetLinkDNSSEC failed.";
            return false;
        }
    }
    return true;
}

/**
 * Call `SetLinkDNS`, `SetLinkDomains`, and `SetLinkDNSSEC` on the `Resolve1Manager` interface.
 *
 * The network interface name is retrieved from the environment variable `PPP_IFACE`.
 *
 * @tparam Manager The type of the Resolve1Manager interface.
 * @return true if all calls were successful, false otherwise.
 */
template <class Manager = Resolve1Manager>
class Up {
public:
    // LCOV_EXCL_START
    /**
     * Constructor for Up.
     *
     * @param connection The QDBusConnection to use for D-Bus calls.
     */
    Up(const QDBusConnection &connection)
        : connection_(connection), dbus_iface_(getDBusInterface()),
          container_(Resolve1ManagerContainer<Manager>(dbus_iface_)) {
    }
    // LCOV_EXCL_STOP
    /**
     * Call `SetLinkDNS`, `SetLinkDomains`, and `SetLinkDNSSEC` on the `Resolve1Manager` interface.
     *
     * The network interface name is retrieved from the environment variable `PPP_IFACE`.
     *
     * @return true if all calls were successful, false otherwise.
     */
    bool up() {
        const auto devIndex = netDeviceIndex();
        if (dbus_iface_.isValid()) {
            doSetLinkDns(container_, devIndex);
            doSetLinkDomains(container_, devIndex);
            doSetLinkDnssec(container_, devIndex);
        } else {
            qCCritical(LOG_IFUP_SYSTEMD_RESOLVED) << dbus_iface_.lastError();
            qCCritical(LOG_IFUP_SYSTEMD_RESOLVED) << "Invalid interface!";
            return false;
        }
        return true;
    }

private:
    QString netDeviceEnvVarValue() const {
        return QString(qEnvironmentVariable(Strings::EnvironmentVariableNames::netDevice))
            .trimmed();
    }
    // LCOV_EXCL_START
    virtual QNetworkInterface interfaceFromName(const QString &name) const {
        return QNetworkInterface::interfaceFromName(name);
    }
    // LCOV_EXCL_STOP
    int netDeviceIndex() const {
        const auto netDevEnvValue = netDeviceEnvVarValue();
        if (netDevEnvValue.isEmpty()) {
            qCCritical(LOG_IFUP_SYSTEMD_RESOLVED) << "Empty network device name.";
            return -1;
        }
        const auto iface = interfaceFromName(netDevEnvValue);
        if (!iface.isValid()) {
            qCCritical(LOG_IFUP_SYSTEMD_RESOLVED)
                << "Invalid network device name:" << netDevEnvValue;
            return -1;
        }
        const auto devIndex = iface.index();
        if (devIndex == 0) {
            qCWarning(LOG_IFUP_SYSTEMD_RESOLVED) << "Unusual to have network device index 0.";
        }
        return devIndex;
    }
    // LCOV_EXCL_START
    virtual Manager getDBusInterface() const {
        return Resolve1Manager(
            Strings::DBus::Services::resolve1, Strings::DBus::Paths::resolve1, connection_);
    }
    // LCOV_EXCL_STOP

    QDBusConnection connection_;
    Manager dbus_iface_;
    Resolve1ManagerContainer<Manager> container_;
};
